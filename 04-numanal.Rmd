# Numerical Methods

## Introduction

### Computer representation of real numbers

Any positive decimal number $x$ is represented by the ordered coefficents $\{ d_j : j = n, n - 1, \ldots \} \subseteq \{ 0, 1, \ldots, 9 \}$

\begin{equation}
  x = d_n 10^n + d_{n - 1} 10 ^{n - 1} + \cdots + d_1 10 + d_0 + d_{-1} 10^{-1} + \cdots
  (\#eq:decimal)
\end{equation}

For same number $x$, other base $2$ can also be used with binary digits $\{ a_j \} \subseteq \{ 0, 1 \}$

\begin{equation}
  x = a_k 2^k + a_{k - 1} 2 ^{k - 1} + \cdots + a_1 2 + a_0 + a_{-1} 2^{-1} + \cdots
  (\#eq:base2)
\end{equation}

Point between $a_0$ and $a_{-1}$ is called the radix point here.

```{r}
sfsmisc::digitsBase(320, base = 10)
sfsmisc::digitsBase(320, base = 2)
```

See Equations \@ref(eq:decimal) and \@ref(eq:base2). Numbers are expressed with series.

```{example, machineeps, name = "Identical and nearly equal"}
$0.3 - 0.1$ is equal to $0.2$. Can we check this?
```

```{r}
(.3 - .1) == .2
```

It is obviously same, but `R` says it is different. Why?

```{r}
.Machine$double.eps
```

The above number is the smallest positive floating number that the machine can recognize. `all.equal()` function can solve this kind of near-equality problem.

```{r}
all.equal(.2, .3 - .1)
```


## Root-finding in One Dimension

In statistics, it is one of issues to find solutions of

$$f(x) = 0$$

There are various algorithms.

### Bisection method

```{r bisecfig, echo=FALSE, fig.cap="Illustration of bisection method"}
tibble(x = c(0, 2)) %>% 
  ggplot(aes(x = x)) +
  modelr::geom_ref_line(h = 0) +
  stat_function(fun = function(x) {
    (x - 3)^2 - 2
  }) +
  geom_vline(xintercept = c(.5, 1.7), alpha = .5, col = I("grey10")) +
  annotate(
    geom = "point",
    x = -sqrt(2) + 3,
    y = 0,
    col = "red",
    shape = 1
  )
```

Figure \@ref(fig:bisecfig) presents the motivation of bisection method. On both sides of the root, one side of function value is positive and the other side is negative. Thus, if we find any set like this, then we only narrow the two points until finding the solution.

\begin{algorithm}[H] \label{alg:bisection}
  \SetAlgoLined
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{Equation system $f(x) = 0$, error bound $\epsilon$}
  Initialize two points $x_0$ and $x_1$ such that $$f(x_0) f(x_1) \le 0$$\;
  \If{$f(x_0) f(x_1) < 0$}{
    Change initial values\;
  }
  Set error $e = \lvert x_1 - x_0 \rvert$\;
  \While{$e > \epsilon$}{ \label{alg:bisecwhile}
    Half $$x_2 = \frac{x_0 + x_1}{2}$$\;
    Length of the interval becomes half $e = \frac{e}{2}$\;
    \eIf{$f(x_0) f(x_2) < 0$}{
      Update $x_1 = x_2$\;
    }{
      Update $x_0 = x_2$\;
    }
  }
  \Output{$x = x_2$}
  \caption{Bisection algorithm}
\end{algorithm}

In Line $\ref{alg:bisecwhile}$, we can use condition

$$\lvert f(x_2) \rvert > \epsilon$$

instead, which means that we did not find the root yet.

```{example, bisecexm}
Solve $$a^2 + y^2 + \frac{2ay}{n - 1} = n - 2$$

where $a$ is a specified constant and $n > 2$ is an integer.
```

```{solution}
It can be shown that the analytical solution is

$$y = - \frac{a}{n - 1} \pm \sqrt{n - 2 + a^2 + \Big( \frac{a}{n - 1} \Big)^2}$$
```

```{r}
f_bisec <- function(x, a = .5, n = 20) {
  a^2 + x^2 + 2 * a * x / (n - 1) - (n - 2)
}
#-----------------------------
bisection <- function(x0, x1, fun, eps = .Machine$double.eps^.25, rep_max = 1000, ...) {
  iter <- 0 # stop too many iteration
  if (fun(x0, ...) * fun(x1, ...) > 0) {
    stop(gettextf("both %s and %s should be satisfy the condition", expression(x0), expression(x1)))
  }
  init <- seq(x0, x1, length.out = 3) # x0 x2 x1
  y <- f_bisec(init)
  while (iter < 1000 && abs(y[2]) > eps) {
    iter <- iter + 1
    if (y[1] * y[2] < 0) {
      init[3] <- init[2]
      y[3] <- y[2]
    } else {
      init[1] <- init[2]
      y[1] <- y[2]
    }
    init[2] <- (init[1] + init[3]) / 2
    y[2] <- fun(init[2], ...)
  }
  c(init[2], y[2])
}
```

Using initioal values $x_0 = 0$ and $X_1 = 100$,

```{r}
(bi_exm <- bisection(0, 100, fun = f_bisec, a = .5, n = 20))
```

$x = `r bi_exm[1]`$ has been computed. The following figure shows that this answer is reasonable.

```{r bisecroot, echo=FALSE, fig.cap="Example curve"}
tibble(x = c(0, 10)) %>% 
  ggplot(aes(x = x)) +
  modelr::geom_ref_line(h = 0) +
  stat_function(fun = f_bisec) +
  annotate(
    geom = "point", 
    x = bi_exm[1], 
    y = f_bisec(bi_exm[1]), 
    col = "red", 
    shape = 4,
    size = 3
  )
```

### Brent's method

Brent's method combines the root bracketing and bisection with inverse quadratic interpolation. `uniroot()` uses this method. Refer to Example \@ref(exm:bisecexm).

```{r}
(brent <- 
  uniroot(
    f = f_bisec,
    interval = c(0, 100),
    a = .5,
    n = 20
  ))
```

This method assures convergence of the bisection method. Morover, it is generally faster than bisection.


## Numerical Integration

Try to compute

$$I = \int_a^b f(x) dx$$

### Trapezoidal rule

From definition of Riemann integration, we can compute integration $I$ by partitioning intervals. Areas of rectangles can be considered or trapezoids can also be considered. If we use trapezoids, it will be more closed to the target curve, but the formula might be quite complex. For the length of subintervals $h = \frac{b - a}{n}$,

\begin{equation}
  \frac{h}{2} f(a) + h \sum_{i = 1}^{n - 1} f(x_i) + \frac{h}{2} f(b)
  (\#eq:trape)
\end{equation}

For fun, we use `Rcpp` for trapezoid method. `Rcpp` integrate `R` and `C++`. This accelerate execution speed like loop.

```{r, eval=FALSE}
library(Rcpp)
```

The following code should be written in `cpp` file separately, or in `cppFunction()` as character.

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector trapezoid(Function target, double a, double b, int n) {
  double h = (b - a) / n;
  NumericVector fa = target(a);
  NumericVector fb = target(b);
  NumericVector integral = (fa + fb) / 2;
  double x = a;
  NumericVector fx = target(x);
  
  for(int i = 0; i < n; i++) {
    x += h;
    NumericVector fx = target(x);
    integral += fx;
  }
  
  integral = integral * h;
  
  return(integral);
}
```

Consider standard normal densitiy. Compare

$$P(-1.96 \le Z \le 1.96)$$

```{r}
phi <- function(x) {
  1 / sqrt(2 * pi) * exp(- x^2 / 2)
}
#----------------------------------
tibble(x1 = -1.96, x2 = 1.96) %>% 
  summarise(
    trapezoid = trapezoid(
      phi,
      a = x1,
      b = x2,
      n = 100
    ),
    pnorm = pnorm(x2) - pnorm(x1)
  )
```

### Adaptive quadrature method

`R` provides a function `integrate()`. This implements a method called an *adaptive quadrature method*. Get

$$\int_0^{\infty} \frac{1}{(\cosh y - \rho r)^{n - 1}}dy$$

with $\rho \in (-1, 1)$, $r \in (-1, 1)$, and $n \ge 2$ integer.

```{r}
integrate_exm <- function(y, n, r, rho) {
  (cosh(y) - rho * r)^(1 - n)
}
```

Denote that $\rho$, $r$, and $n$ should be pre-specified. Consider $(0.2, 0.5, 10)$.

```{r}
integrate(
  f = integrate_exm,
  lower = 0,
  upper = Inf,
  n = 10,
  r = .5,
  rho = .2
)
```


## Maximum Likelihood Problems




## One-Dimensional Optimization


## Two-Dimensional Optimization


```{r}
mix_ll <- function(param, y) {
  # mixing probability
  prob <- param[1:2]
  prob <- c(prob, 1 - sum(prob))
  # rate of dgamma
  rate <- param[3:4]
  rate <- c(rate, 1 - sum(rate)) # constraint
  dens <-
    sapply(rate, function(b) {
      dgamma(x = y, shape = 1 / 2, rate = 1 / (2 * b))
    }) %*%
    diag(prob) %>% 
    rowSums()
  -sum(log(dens))
}
```

```{r}
init_lam <- 
  sample(
    c(.6, .25, .15),
    size = 2000,
    replace = TRUE
  )
y <- rgamma(2000, shape = 1 / 2, rate =  1 / (2 * init_lam))
```

```{r}
opt <- optim(c(.3, .3, .5, .3), mix_ll, y = y)
```

```{r}
opt_df <- 
  broom::tidy(opt) %>% 
  spread(parameter, value)
#---------------------
colnames(opt_df) <- c("prob1", "prob2", "lambda1", "lambda2")
opt_df %>% 
  mutate(
    prob3 = 1 - prob1 - prob2,
    lambda3 = 1 - lambda1 - lambda2
  ) %>% 
  select(order(colnames(.)))
```


## EM Algorithm




